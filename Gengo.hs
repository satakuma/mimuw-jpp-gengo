-- File generated by the BNF Converter (bnfc 2.9.3).

-- | Program to test parser.

module Main where

import Prelude
  ( ($), (.)
  , Either(..)
  , Int, (>)
  , String, (++), concat, unlines
  , Show, show
  , IO, (>>), (>>=), mapM_, putStrLn
  , FilePath
  , getContents, readFile
  , fromInteger
  )
import System.IO ( stdin, stderr, hPutStrLn )
import System.Environment ( getArgs )
import System.Exit        ( exitFailure, exitSuccess, exitWith, ExitCode(..) )
import Control.Monad      ( when )

import AbsGengo   ()
import LexGengo   ( Token, mkPosToken )
import ParGengo   ( pProgram, myLexer )
import PrintGengo ( Print, printTree )
import SkelGengo  ()
import Interpreter
import Typecheck

type Verbosity  = Int

putStrV :: Verbosity -> String -> IO ()
putStrV v s = when (v > 1) $ putStrLn s

runFile :: Verbosity -> FilePath -> IO ()
runFile v f = putStrLn f >> readFile f >>= run v

run :: Verbosity -> String -> IO ()
run v input =
  let tokens = myLexer input
    in case pProgram tokens of
         Left err -> do
           putStrV v "Parse failed...\n"
           putStrV v "Tokens:"
           mapM_ (putStrV v . showPosToken . mkPosToken) tokens
           hPutStrLn stderr err
           exitFailure
         Right tree -> do
           putStrV v "Parse successful!"
           showTree v tree
           putStrV v "Typechecking..."
           typecheckRes <- runTypecheck $ typecheck tree
           case typecheckRes of
             Left err -> do
               hPutStrLn stderr (show err)
               exitFailure
             Right _ -> do
               putStrV v "Typecheck successful!\n"
               interpretRes <- runInterpreter $ interpret tree
               -- interpretRes <- runTypecheck $ typecheck tree
               case interpretRes of
                 Left err -> do
                   hPutStrLn stderr (show err)
                   exitFailure
                 Right (VInt exitCode) -> case exitCode of
                   0 -> exitSuccess
                   _ -> exitWith (ExitFailure (fromInteger exitCode))
  where
  showPosToken ((l,c),t) = concat [ show l, ":", show c, "\t", show t ]

showTree :: (Show a, Print a) => Int -> a -> IO ()
showTree v tree = do
  putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
  putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree


main :: IO ()
main = do
  args <- getArgs
  case args of
    [] -> getContents >>= run 2
    fs -> mapM_ (runFile 2) fs

